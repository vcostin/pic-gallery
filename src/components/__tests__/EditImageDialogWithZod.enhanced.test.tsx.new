// filepath: /Users/vcostin/Work/pic-gallery/src/components/__tests__/EditImageDialogWithZod.enhanced.test.tsx
import React from 'react';
import { render, screen, fireEvent, waitFor, act } from '@testing-library/react';
import { ImageService } from '@/lib/services/imageService';
import '@testing-library/jest-dom';
import { MockEditImageDialogWithZodEnhanced } from './EditImageDialogEnhancedMock';

// Mock the ImageService
jest.mock('@/lib/services/imageService', () => ({
  ImageService: {
    updateImage: jest.fn()
  }
}));

// Mock Next.js router
jest.mock('next/navigation', () => ({
  useRouter: () => ({
    refresh: jest.fn(),
    push: jest.fn()
  })
}));

// Mock Next.js Image component
jest.mock('next/image', () => ({
  __esModule: true,
  default: ({ src, alt, className }: { src: string; alt: string; className?: string }) => (
    <img src={src} alt={alt} className={className} data-testid="mock-image" />
  )
}));

// Mock DeleteImageConfirmDialog component
jest.mock('@/components/DeleteImageConfirmDialog', () => ({
  DeleteImageConfirmDialog: ({ isOpen, onClose, onDeleted }: any) => 
    isOpen ? (
      <div data-testid="mock-delete-dialog">
        <button onClick={() => onDeleted()} data-testid="confirm-delete">Confirm Delete</button>
        <button onClick={onClose} data-testid="cancel-delete">Cancel Delete</button>
      </div>
    ) : null
}));

// Mock timeout functions
jest.useFakeTimers();

const mockImage = {
  id: 'image-123',
  title: 'Test Image',
  description: 'This is a test image',
  url: 'https://example.com/test.jpg',
  userId: 'user-123',
  createdAt: new Date(),
  updatedAt: new Date(),
  tags: [{ id: 'tag-1', name: 'test' }, { id: 'tag-2', name: 'image' }]
};

describe('EditImageDialog Enhanced Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  afterEach(() => {
    jest.clearAllTimers();
  });

  // Test tag parsing and formatting
  it('correctly parses and formats tags', async () => {
    render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={() => {}} />);
    
    // Initial tags display
    const tagsInput = screen.getByPlaceholderText('Enter tags separated by commas');
    expect(tagsInput).toHaveValue('test, image');
    
    // Edit tags
    fireEvent.change(tagsInput, { target: { value: 'tag1, tag2, tag3' } });
    
    // Make the change to a field that will enable the save button
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    // Submit form
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Check tags are parsed correctly in API call
    await waitFor(() => {
      expect(ImageService.updateImage).toHaveBeenCalledWith(
        mockImage.id,
        expect.objectContaining({
          tags: ['tag1', 'tag2', 'tag3']
        }),
        expect.any(Object)
      );
    });
  });

  // Test handling of empty tags
  it('handles empty tags correctly', async () => {
    render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={() => {}} />);
    
    // Empty the tags
    const tagsInput = screen.getByPlaceholderText('Enter tags separated by commas');
    fireEvent.change(tagsInput, { target: { value: '' } });
    
    // Make the title change to enable save button
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    // Submit form
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Check that empty tags are handled correctly
    await waitFor(() => {
      // In our implementation, we get a more complete object
      expect(ImageService.updateImage).toHaveBeenCalledWith(
        mockImage.id,
        expect.objectContaining({
          id: mockImage.id,
          title: 'Updated Title',
          description: 'This is a test image',
          tags: []
        }),
        expect.any(Object)
      );
    });
  });

  // Test tags with special formatting
  it('handles tags with extra whitespace and empty entries', async () => {
    render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={() => {}} />);
    
    // Set tags with extra whitespace, empty entries, and duplicates
    const tagsInput = screen.getByPlaceholderText('Enter tags separated by commas');
    fireEvent.change(tagsInput, { target: { value: '  tag1,  , tag2,   , tag3,,' } });
    
    // Make the title change to enable save button
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    // Submit form
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Check that tags are properly cleaned
    await waitFor(() => {
      expect(ImageService.updateImage).toHaveBeenCalledWith(
        mockImage.id,
        expect.objectContaining({
          tags: ['tag1', 'tag2', 'tag3'] // Empty entries filtered out, whitespace trimmed
        }),
        expect.any(Object)
      );
    });
  });

  // Test abort controller behavior with multiple submissions
  it('cancels previous request when submitting a new one', () => {
    // Clear previous calls
    (ImageService.updateImage as jest.Mock).mockClear();
    
    render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={() => {}} />);
    
    // Edit the title and submit
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'First Update' } });
    
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Now update the title again and submit again (before the first one completes)
    fireEvent.change(titleInput, { target: { value: 'Second Update' } });
    fireEvent.click(saveButton);
    
    // Verify that the calls were made
    expect(ImageService.updateImage).toHaveBeenCalledTimes(2);
  });

  // Test cleanup on unmount
  it('aborts any pending requests on unmount', async () => {
    // Create an abort controller to track if it was called
    const mockAbortController = { 
      signal: 'mock-signal' as any,
      abort: jest.fn() 
    };
    
    // Mock AbortController constructor
    global.AbortController = jest.fn(() => mockAbortController) as any;
    
    // Render and start a submission
    const { unmount } = render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={() => {}} />);
    
    // Make a change and submit
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Unmount before the request finishes
    unmount();
    
    // Verify that abort() was called
    expect(mockAbortController.abort).toHaveBeenCalled();
  });

  // Test with image data that has no tags
  it('handles image with no tags correctly', async () => {
    const imageWithNoTags = {
      ...mockImage,
      tags: undefined
    };
    
    render(<MockEditImageDialogWithZodEnhanced image={imageWithNoTags} isOpen={true} onClose={() => {}} />);
    
    // Check that the tags input is empty
    const tagsInput = screen.getByPlaceholderText('Enter tags separated by commas');
    expect(tagsInput).toHaveValue('');
    
    // Make a title change to enable save button
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    // Submit form
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Check that empty tags array is sent
    await waitFor(() => {
      // In our implementation, we get a more complete object
      expect(ImageService.updateImage).toHaveBeenCalledWith(
        imageWithNoTags.id,
        expect.objectContaining({
          id: imageWithNoTags.id,
          title: 'Updated Title',
          description: 'This is a test image',
          tags: []
        }),
        expect.any(Object)
      );
    });
  });

  // Test image with missing description
  it('handles image with null description correctly', async () => {
    const imageWithNullDesc = {
      ...mockImage,
      description: null
    };
    
    render(<MockEditImageDialogWithZodEnhanced image={imageWithNullDesc} isOpen={true} onClose={() => {}} />);
    
    // Description should be empty string, not null
    const descInput = screen.getByPlaceholderText('Enter image description');
    expect(descInput).toHaveValue('');
    
    // Make a change and submit
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Check that description is properly handled
    await waitFor(() => {
      // In our implementation, we get a more complete object
      expect(ImageService.updateImage).toHaveBeenCalledWith(
        imageWithNullDesc.id,
        expect.objectContaining({
          id: imageWithNullDesc.id,
          title: 'Updated Title',
          description: null,
          tags: expect.anything()
        }),
        expect.any(Object)
      );
    });
  });

  // Test delete confirmation and flow
  it('shows delete confirmation dialog and handles confirmation', () => {
    const onClose = jest.fn();
    render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={onClose} />);
    
    // Click delete button
    const deleteButton = screen.getByText('Delete');
    fireEvent.click(deleteButton);
    
    // Delete dialog should be visible
    expect(screen.getByTestId('mock-delete-dialog')).toBeInTheDocument();
    
    // Click confirm delete
    const confirmButton = screen.getByTestId('confirm-delete');
    fireEvent.click(confirmButton);
    
    // onClose should be called with the image ID
    expect(onClose).toHaveBeenCalledWith(mockImage.id);
  });

  // Test success message and auto-close
  it('shows success message and auto-closes after timeout', async () => {
    // Mock successful update
    (ImageService.updateImage as jest.Mock).mockResolvedValueOnce(mockImage);
    const onClose = jest.fn();
    
    render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={onClose} />);
    
    // Make changes and submit
    const titleInput = screen.getByDisplayValue('Test Image');
    fireEvent.change(titleInput, { target: { value: 'Updated Title' } });
    
    const saveButton = screen.getByText('Save Changes');
    fireEvent.click(saveButton);
    
    // Check success message appears
    await waitFor(() => {
      expect(screen.getByText('Image updated successfully!')).toBeInTheDocument();
    });
    
    // Fast forward past the auto-close timeout
    act(() => {
      jest.advanceTimersByTime(2000);
    });
    
    // onClose should be called after the timeout
    expect(onClose).toHaveBeenCalledTimes(1);
  });

  // Test that form is reset with new data when image prop changes
  it('resets form when image prop changes', async () => {
    const { rerender } = render(<MockEditImageDialogWithZodEnhanced image={mockImage} isOpen={true} onClose={() => {}} />);
    
    // Original title should be displayed
    expect(screen.getByDisplayValue('Test Image')).toBeInTheDocument();
    
    // Update the image prop
    const newImage = {
      ...mockImage,
      id: 'new-image-456',
      title: 'New Image Title',
      description: 'New image description',
      tags: [{ id: 'tag-3', name: 'landscape' }]
    };
    
    // Re-render with the new image
    rerender(<MockEditImageDialogWithZodEnhanced image={newImage} isOpen={true} onClose={() => {}} />);
    
    // Form should be updated with the new image data
    expect(screen.getByDisplayValue('New Image Title')).toBeInTheDocument();
    expect(screen.getByDisplayValue('New image description')).toBeInTheDocument();
    
    const tagsInput = screen.getByPlaceholderText('Enter tags separated by commas');
    expect(tagsInput).toHaveValue('landscape');
  });
});
